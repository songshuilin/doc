## 对称加密和非对称加密总结与实践 ##

### 序言 ###


### 相关概念 ###

明文： 数据没有进行加密，原始数据信息。

密文： 加密过后得到的数据， 隐藏了原始数据的含义。

加密 ： 将明文转为密文的过程。

解密 ： 将密文转为明文的过程。

密钥： 是一种参数，是在加密或解密中输入的参数。

### 对称加密 ###

定义： 指的是加密与解密使用相同的密钥。这种加密方式称为对称加密。

对称加密一般有： DES 、 3DES 、 AES

- DES（Data Encryption Standard）： 数据加密标准，速度较快，适用于加密大量数据的场合。
- 3DES（Triple DES）: 基于DES, 对一块数据用三个不同的密钥进行三次加密，强度更高。 
- AES（Advanced Encryption Standard）: 高级加密标准，是下一代的加密算法标准，速度快，安全级别高，支持128、192、256、512位密钥的加密。

对称加密特征： 

- 加密方和解密方使用同一个密钥。
- 加密加密的速度较快。
- 密钥传输过程不安全，且容易被破解，密钥管理也很麻烦。

代码实现：

DES算法：
	
	
    /**
     * @program
     * @Desc
     * @Author 游戏人日常
     * @CreateTime 2019/07/20--15:21
     */
    public class DesTest {
        //转化格式
        public  static final String TRAMSFORMATION = "DES/ECB/PKCS5Padding";
        //算法  DES
        public static  final String ALGORITHM = "DES" ;
        //待加密的源串
        public static final  String  msg = "helloWorld";
        //密钥
        public  static  final  String key = "123456781234567812345678";
    
        public  static void main(String args[]){
            System.out.println("加密之前的信息： "+ msg);
            //加密
           String encryptMsg = encrypt(msg,key);
           System.out.println("加密之后的信息： "+ encryptMsg);
           //解密
           String decryptMsg = dedecrypt();
           System.out.println("解密密之后的信息： "+ encryptMsg);
        }
        //解密
        private static String dedecrypt() {
    
            return  null;
        }
    
        /**
         *
         * @param encryptionStr  待加密的串
         * @param password  密钥
         * @return
         */
        public static String encrypt(String encryptionStr, String password){
            try{
                byte[] encryptionBytes = encryptionStr.getBytes("UTF-8");
                SecureRandom random = new SecureRandom();
                DESKeySpec desKey = new DESKeySpec(password.getBytes());
                // 创建一个密钥工厂，然后用它把DESKeySpec转换成
                SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(ALGORITHM);
                SecretKey securekey = keyFactory.generateSecret(desKey);
                // Cipher对象实际完成加密操作
                Cipher cipher = Cipher.getInstance(TRAMSFORMATION);
                // 用密钥初始化Cipher对象
                cipher.init(Cipher.ENCRYPT_MODE, securekey, random);
                // 执行加密操作
                byte[] encryptionBase64Bytes = cipher.doFinal(encryptionBytes);
                // 转换为字符串返回
                return new BigInteger(encryptionBase64Bytes).toString(16);
            }catch(Exception e){
                e.printStackTrace();
            }
            return null;
        }
    }
